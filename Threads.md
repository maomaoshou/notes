# Threads

线程底层的实现是Mach threads。

## 基础概念

* 同步：不能开启新线程
* 异步：可以开启新线程
* `dispath_sync`:立马在当前线程执行任务，执行完才能进行下一项
* `dispath_async`:不要求立马在当前线程执行任务，可能会开启新线程也可能不会
* 同步串行队列：不会创建新线程，任务按顺序执行
* 同步并行队列：不会创建新线程，任务按顺序执行
* 异步串行队列：根据需要可能会创建新线程，任务按顺序执行
* 异步并行队列：根据需要创建新线程，任务无序执行
* 不同串行队列的任务同步添加到同一个线程，不会造成死锁
* 串行队列上同步执行任务死锁的原因：串行队列要等待dispath_sync任务的结束才能执行下一任务，dispath_sync的结束依赖于block，block要等dispath_sync执行结束。例如：
```
dispath_sync(dispath_get_main_queue(), ^ {
    NSLog("111")；
})
```
* 线程一旦启动后总是在三种状态之间切换：ready，block，runing
* 同步手段：lock，conditions，atomic operations

## Run Loop

* 每个线程对应一个runloop对象

## 同步工具

1. 锁（Locks）

   * 互斥锁（mutex）：

     在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程

   * 递归锁（rescursive）：

   * 读写锁（read-write）：

   * 分布锁（distributed）：

   * 自旋锁（spin）：

     在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。因为自旋锁不会引起调用者睡眠，所以不会进行线程调度，cpu时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁。但是自旋锁一直占用CPU，他在未获得锁的情况下，一直运行（自旋），所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。自旋锁不能实现递归调用。

   * 双重检查锁（double-checked）:

   * 互斥锁与自旋锁：

2. 条件（Conditions）

3. 原子操作（atomic operations）

## 线程交流

## 应用

* UI操作只能在主线程的原因
  * 并发问题（两个线程同时对同一个控件进行操作，同步问题，view已被移除，但runloop还未结束，用户在主线程进行交互等）

## 其他

### 调度队列（Dispatch Queues）

**概念** 

基于C语言执行任务的调度机制。队列执行任务有并行和串行两种方式，但都是以先进先出的顺序（即队列总是按照任务被加入的顺序开始任务的执行）

**方式**

* 串行：任务必须按顺序执行，必须等当前任务执行结束后再开始下一任务的执行
* 并行：多个任务可以同时进行，根据系统调度机制执行尽可能多的任务，不需要等待当前执行任务的结束

**优点**

* 为开发者提供简单清晰的的api
* 提供自动全面的线程调度
* 提供高效的调度
* 内存使用更高效（因为线程栈不回在应用内存中常驻）
* 不会在负载下捕获到内核
* 任务被异步的提交到队列，不会导致队列死锁
* 串行队列为加锁和其他同步操作提供了更高效的方案

### 调度源（Dispatch Queues）

基于C语言的的装置，可以异步处理特殊类型的系统事件。一个调度源包含部分系统时间，同时在一个特殊的block对象或者方法出现时将它提交到调度队列中。调度源可以用来监测以下类型的系统事件

* Timers
* Signal handlers
* Descriptor-related events
* Process-related events
* Mach port events
* Custom events that you trigger

### 线程队列（Operation Queues）

线程队列和并行的Cocoa调度队列对等，通过`NSOperationQueue`类实现。调度队列总是先进先出的顺序执行任务，但线程队列开始任务执行时会考虑其他因素。这些因素主要包含当前任务是否依赖其他任务的完成。你可以在定义你的任务时配置依赖项并且使用这些依赖项来为你的任务创建复杂的执行时序图

你提交到线程队列的任务必须是`NSOperation`类的实例。`operation`是一个OC对象，包含了你想执行的任务和执行该任务所需要的数据。由于`NSOperation`类是一个抽象基类，一般来说你会自定义一个子类来实现你的任务。`Foundation`框架中包含某些你可以创建且用它来执行任务的`concrete subclasses`

`Operation`对象支持`KVO`,这个特性可以作为一个很有用的监测`task`执行进度的方式。虽然`operation`对象总是并行的执行任务，必要时你可以使用依赖项来保证执行顺序是串行的

